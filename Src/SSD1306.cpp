#include "SSD1306.h"

namespace FwLogger
{

	const uint8_t builtin_font[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, // sp
		0x00, 0x00, 0x2f, 0x00, 0x00, // !
		0x00, 0x07, 0x00, 0x07, 0x00, // "
		0x14, 0x7f, 0x14, 0x7f, 0x14, // #
		0x24, 0x2a, 0x7f, 0x2a, 0x12, // $
		0x23, 0x13, 0x08, 0x64, 0x62, // %
		0x36, 0x49, 0x55, 0x22, 0x50, // &
		0x00, 0x05, 0x03, 0x00, 0x00, // '
		0x00, 0x1c, 0x22, 0x41, 0x00, // (
		0x00, 0x41, 0x22, 0x1c, 0x00, // )
		0x14, 0x08, 0x3E, 0x08, 0x14, // *
		0x08, 0x08, 0x3E, 0x08, 0x08, // +
		0x00, 0x00, 0xA0, 0x60, 0x00, // ,
		0x08, 0x08, 0x08, 0x08, 0x08, // -
		0x00, 0x60, 0x60, 0x00, 0x00, // .
		0x20, 0x10, 0x08, 0x04, 0x02, // /
		0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
		0x00, 0x42, 0x7F, 0x40, 0x00, // 1
		0x42, 0x61, 0x51, 0x49, 0x46, // 2
		0x21, 0x41, 0x45, 0x4B, 0x31, // 3
		0x18, 0x14, 0x12, 0x7F, 0x10, // 4
		0x27, 0x45, 0x45, 0x45, 0x39, // 5
		0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
		0x01, 0x71, 0x09, 0x05, 0x03, // 7
		0x36, 0x49, 0x49, 0x49, 0x36, // 8
		0x06, 0x49, 0x49, 0x29, 0x1E, // 9
		0x00, 0x36, 0x36, 0x00, 0x00, // :
		0x00, 0x56, 0x36, 0x00, 0x00, // ;
		0x08, 0x14, 0x22, 0x41, 0x00, // <
		0x14, 0x14, 0x14, 0x14, 0x14, // =
		0x00, 0x41, 0x22, 0x14, 0x08, // >
		0x02, 0x01, 0x51, 0x09, 0x06, // ?
		0x32, 0x49, 0x59, 0x51, 0x3E, // @
		0x7C, 0x12, 0x11, 0x12, 0x7C, // A
		0x7F, 0x49, 0x49, 0x49, 0x36, // B
		0x3E, 0x41, 0x41, 0x41, 0x22, // C
		0x7F, 0x41, 0x41, 0x22, 0x1C, // D
		0x7F, 0x49, 0x49, 0x49, 0x41, // E
		0x7F, 0x09, 0x09, 0x09, 0x01, // F
		0x3E, 0x41, 0x49, 0x49, 0x7A, // G
		0x7F, 0x08, 0x08, 0x08, 0x7F, // H
		0x00, 0x41, 0x7F, 0x41, 0x00, // I
		0x20, 0x40, 0x41, 0x3F, 0x01, // J
		0x7F, 0x08, 0x14, 0x22, 0x41, // K
		0x7F, 0x40, 0x40, 0x40, 0x40, // L
		0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
		0x7F, 0x04, 0x08, 0x10, 0x7F, // N
		0x3E, 0x41, 0x41, 0x41, 0x3E, // O
		0x7F, 0x09, 0x09, 0x09, 0x06, // P
		0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
		0x7F, 0x09, 0x19, 0x29, 0x46, // R
		0x46, 0x49, 0x49, 0x49, 0x31, // S
		0x01, 0x01, 0x7F, 0x01, 0x01, // T
		0x3F, 0x40, 0x40, 0x40, 0x3F, // U
		0x1F, 0x20, 0x40, 0x20, 0x1F, // V
		0x3F, 0x40, 0x38, 0x40, 0x3F, // W
		0x63, 0x14, 0x08, 0x14, 0x63, // X
		0x07, 0x08, 0x70, 0x08, 0x07, // Y
		0x61, 0x51, 0x49, 0x45, 0x43, // Z
		0x00, 0x7F, 0x41, 0x41, 0x00, // [
		0x55, 0x2A, 0x55, 0x2A, 0x55, // 55
		0x00, 0x41, 0x41, 0x7F, 0x00, // ]
		0x04, 0x02, 0x01, 0x02, 0x04, // ^
		0x40, 0x40, 0x40, 0x40, 0x40, // _
		0x00, 0x01, 0x02, 0x04, 0x00, // '
		0x20, 0x54, 0x54, 0x54, 0x78, // a
		0x7F, 0x48, 0x44, 0x44, 0x38, // b
		0x38, 0x44, 0x44, 0x44, 0x20, // c
		0x38, 0x44, 0x44, 0x48, 0x7F, // d
		0x38, 0x54, 0x54, 0x54, 0x18, // e
		0x08, 0x7E, 0x09, 0x01, 0x02, // f
		0x18, 0xA4, 0xA4, 0xA4, 0x7C, // g
		0x7F, 0x08, 0x04, 0x04, 0x78, // h
		0x00, 0x44, 0x7D, 0x40, 0x00, // i
		0x40, 0x80, 0x84, 0x7D, 0x00, // j
		0x7F, 0x10, 0x28, 0x44, 0x00, // k
		0x00, 0x41, 0x7F, 0x40, 0x00, // l
		0x7C, 0x04, 0x18, 0x04, 0x78, // m
		0x7C, 0x08, 0x04, 0x04, 0x78, // n
		0x38, 0x44, 0x44, 0x44, 0x38, // o
		0xFC, 0x24, 0x24, 0x24, 0x18, // p
		0x18, 0x24, 0x24, 0x18, 0xFC, // q
		0x7C, 0x08, 0x04, 0x04, 0x08, // r
		0x48, 0x54, 0x54, 0x54, 0x20, // s
		0x04, 0x3F, 0x44, 0x40, 0x20, // t
		0x3C, 0x40, 0x40, 0x20, 0x7C, // u
		0x1C, 0x20, 0x40, 0x20, 0x1C, // v
		0x3C, 0x40, 0x30, 0x40, 0x3C, // w
		0x44, 0x28, 0x10, 0x28, 0x44, // x
		0x1C, 0xA0, 0xA0, 0xA0, 0x7C, // y
		0x44, 0x64, 0x54, 0x4C, 0x44, // z
		0x00, 0x08, 0x77, 0x00, 0x00, // {
		0x00, 0x00, 0x7F, 0x00, 0x00, // |
		0x00, 0x77, 0x08, 0x00, 0x00, // }
		0x10, 0x08, 0x10, 0x08, 0x00, // ~
	};

	void SSD1306::isr()
	{
		_isrFlag = true;
	}

	SSD1306::SSD1306(I2C_HandleTypeDef* hi2c, uint8_t addr, uint16_t width, uint16_t height) : Module("SSD1306",'D', 1, 0)
	{
		_hi2c = hi2c;
		_addr = addr;
		_width = width;
		_height = height;

		_color = White;
	}

	void SSD1306::Init()
	{
		/* Init LCD */
		writeCommand(0xAE); //display off
		writeCommand(0x20); //Set Memory Addressing Mode
		writeCommand(0x00); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
		writeCommand(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
		writeCommand(0xC0); //Set COM Output Scan Direction
		writeCommand(0x00); //---set low column address
		writeCommand(0x10); //---set high column address
		writeCommand(0x40); //--set start line address
		writeCommand(0x81); //--set contrast control register
		writeCommand(0xFF);
		writeCommand(0xA0); //--set segment re-map 0 to 127
		writeCommand(0xA6); //--set normal display
		writeCommand(0xA8); //--set multiplex ratio(1 to 64)
		writeCommand(0x1F); //
		writeCommand(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
		writeCommand(0xD3); //-set display offset
		writeCommand(0x00); //-not offset
		writeCommand(0xD5); //--set display clock divide ratio/oscillator frequency
		writeCommand(0xF0); //--set divide ratio
		writeCommand(0xD9); //--set pre-charge period
		writeCommand(0x22); //
		writeCommand(0xDA); //--set com pins hardware configuration
		writeCommand(0x02);
		writeCommand(0xDB); //--set vcomh
		writeCommand(0x20); //0x20,0.77xVcc
		writeCommand(0x8D); //--set DC-DC enable
		writeCommand(0x14); //
		writeCommand(0xAF); //--turn on SSD1306 panel

		setColor(White);
		fill();

		updateScreen();

		_cursorX = 0;
		_cursorY = 0;
		for(int i = 0; i < 128*4; ++i)
			_buf[i] = 0;

		_initialized = 1;
	}

	void SSD1306::setColor(Color color)
	{
		_color = color;
	}

	void SSD1306::fill(Color color)
	{
		/* Set memory */
		uint32_t i;

		for(i = 0; i < sizeof(_buf); i++)
		{
			_buf[i] = (color == White) ? 0xff : 0x00;
		}
	}

	void SSD1306::updateScreen(void)
	{
		writeCommand(0xB0);
		writeCommand(0x00);
		writeCommand(0x10);

		//HAL_I2C_Mem_Write(_hi2c, _addr, 0x40, 1, _buf, _width*4, 1000);
		_cmds.push_back(0x100);
	}

	void SSD1306::drawPixel(uint8_t x, uint8_t y, Color color)
	{
		if (x >= _width || y >= _height) return;

		// Draw in the right color
		if (color == White)
		{
			_buf[x + (y / 8) * _width] |= 1 << (y % 8);
		}
		else
		{
			_buf[x + (y / 8) * _width] &= ~(1 << (y % 8));
		}
	}

	char SSD1306::writeChar(char ch)
	{
		const uint8_t* charGlyph;
		if(ch < ' ') charGlyph = &builtin_font[0];
		else if(ch > '}') charGlyph = &builtin_font[0];
		else charGlyph = &builtin_font[5*(ch-' ')];

		if(_cursorX + 6 > _width)
		{
			_cursorY++;
			_cursorX = 0;
		}

		if(_cursorY > _height/4)
			_cursorY = 0;

		_buf[_cursorX+_cursorY*_width] = 0;
		for(int i = 1; i < 6; ++i)
			_buf[_cursorX+_cursorY*_width+i] = charGlyph[i-1];

		_cursorX += 6;

		return ch;
	}

	char SSD1306::writeString(char* str)
	{
		// Write until null-byte
		while (*str)
		{
			if (writeChar(*str) != *str)
			{
				// Char could not be written
				return *str;
			}

			// Next char
			str++;
		}

		// Everything ok
		return 0;
	}

	void SSD1306::setCursor(uint8_t x, uint8_t y)
	{
		_cursorX = x;
		_cursorY = y;
	}

	void SSD1306::writeCommand(uint8_t command)
	{
		//HAL_I2C_Mem_Write(_hi2c, _addr, 0, 1, &command, 1, 1000);
		_cmds.push_back(command);
		_isrFlag = true;
	}

	bool SSD1306::loop()
	{
		if(_isrFlag)
		{
			_isrFlag = false;
			uint16_t* cmd = _cmds.at_front();
			if(cmd == nullptr) // no left op
			{
				_pendingOp = false;
			}
			else
			{
				_cmds.delete_front();
				_pendingOp = true;
				if(*cmd < 0xff)
				{
					HAL_I2C_Mem_Write_IT(_hi2c, _addr, 0, 1, reinterpret_cast<uint8_t*>(cmd), 1);
				}
				else
				{
					HAL_I2C_Mem_Write_IT(_hi2c, _addr, 0x40, 1, _buf, _width*4);
				}
			}
		}
		return _pendingOp;
	}
}
